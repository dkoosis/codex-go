1. Make Repository Structure Clear and Conventional
Use Go modules (go.mod, go.sum) at the repo root so tools know exact dependencies.

Follow the standard layout (cmd/, pkg/, internal/, etc.) to keep packages and binaries well organized.

Keep a consistent hierarchy so Codex can map file paths to logical components quickly.

2. Add Concise, Machine-Readable Instructions
Place an AGENTS.md (or similar) file in the repository root describing:

Code style (e.g., gofmt vs. goimports).

Build/test instructions (go build, go test, linting tools).

Any project-specific conventions (package naming, directory purpose).

If different subdirectories have special rules, add nested AGENTS.md files so the instructions apply only where needed.

3. Standardize Formatting & Tooling
Enforce formatting automatically with gofmt -w or goimports.

Use linters like golangci-lint or staticcheck and document how to run them.

Provide a Makefile or simple script (./scripts/test.sh) that runs all checks:

gofmt -w ./...
golangci-lint run ./...
go test ./...
4. Pin and Declare Environment Requirements
Specify the Go version in go.mod (go 1.21).

If using tools that require installation (e.g., golangci-lint), document versions and installation steps in AGENTS.md or a README.

Include any environment variables or prerequisites (Docker, database) with defaults or clear instructions.

5. Provide Minimal Reproducible Commands
Document single-line commands for common tasks: build, test, lint, generate mocks.

If multiple steps are required (e.g., generate code then test), tie them together in a script or Make target so Codex can run one command.

6. Keep Tests Fast and Deterministic
Organize tests under _test.go files with clear naming.

Avoid tests that depend on external services; use mocks or in-memory substitutes.

Seed randomness where used to produce deterministic results.

7. Supply Rich Metadata
Add module/package comments and docstrings so Codex can infer purpose and relationships.

Reference third-party packages in comments if they influence implementation choices.

8. Handle Generated Code Carefully
Place generated files under a dedicated directory or name pattern (*_gen.go).

Include // Code generated by ... DO NOT EDIT. headers so tools know what not to modify.

9. Provide Quick Feedback Loops
If possible, include pre-commit hooks or CI scripts that mirror the documented commands.

Ensure scripts exit with non-zero status on failure; Codex relies on this to know if a check passed.

10. Keep the Repository Clean
Commit only source code and essential configs.

Add a .gitignore for build artifacts, IDE files, and local binaries, reducing noise for the tooling.

